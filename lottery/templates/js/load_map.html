{% autoescape off %}
<script type="text/javascript">

// global variables
var map,
    w, h,
    splitPage,
    markers,
    isAuth,
    isEdit,
    selectedInterviewId;

// marker variables
var mh = 26;
var mw = 26;
var sh = 10;
var sw = 4;
var bmh = 200;
var bmw = 200;
var bsh = 10;
var bsw = 4;
var baseRadius = 7;

function projectGeoToMap(coords){
    // this function projects a pair of geographic coords to 
    // the map window space
    var point = map.locationPoint({lat:coords[1],lon:coords[0]});
    return [point.x, point.y];
}
function geoJsonProject(geoJson){
    // this function takes a geojson point and returns
    // a point in the map window space
    return projectGeoToMap(geoJson.geometry.coordinates);
}

function d3GeoJsonLayer(className){
    /*
    This can be a basic layer that does default actions based on the geoJson
    assigned in layer.data()
    */
    var layer = {}, 
        collection; 
    // setup nodes and parent
    // this node will be appended to the map div by 
    // map.addLayer()
    var div = d3.select(document.body)
        .append("div")
        .attr("class", className);
    var svg = div.append('svg');
    var g = svg.append('g');

    layer.parent = div.node();
    layer.map = map;
    // these should be null by default
    layer.customDataFunction = null;
    layer.customDrawFunction = null;

    layer.drawPoints = function(radius){
        layer.features.attr('cy', function(d){ return geoJsonProject(d)[1];})
        .attr('cx', function(d){ return geoJsonProject(d)[0];})
        .attr('r', function(d){ return radius; });
    };
    layer.drawPaths = function(){
        // get d3's path drawing function
        var path = d3.geo.path().projection( projectGeoToMap );
        layer.features.attr("d", path);
    };

    layer.draw = function(){
        // adjust the svg to the layer
        svg.attr("width", layer.map.dimensions.x)
            .attr("height", layer.map.dimensions.y)
            .style("margin-left", "0px")
            .style("margin-top", "0px");
        // if these are points, draw circles
        if (layer.customDrawFunction == null){ // no special drawing function
            if (layer.featureType == 'Point'){
                // default radius is 7
                layer.drawPoints(7);
            } else {
                // but if they are not points, draw paths
                layer.drawPaths();
            }
        } else {
            layer.customDrawFunction(layer.features);
        }
    }; // end draw method

    layer.data = function(geoJsonOrFeatures){
        /* this method takes a geoJson or a list of geoJson features
           and resets layer.features and calculates bounds
        */
        if (geoJsonOrFeatures instanceof Array){
            // this ensures that it can take both a collection
            // and a list of features.
            collection = {"type":"FeatureCollection",
                "features":geoJsonOrFeatures};
            } else {
                collection = geoJsonOrFeatures;
        }
        // get the geometry type from the first feature
        layer.featureType = collection.features[0].geometry.type;
        if (layer.featureType == 'Point'){ // if we have points
            // bounds are [[left, bottom],[right,top]]
            layer.bounds = [
                [
                   d3.min(collection.features, function(f){
                       return f.geometry.coordinates[0]; }),
                   d3.min(collection.features, function(f){
                       return f.geometry.coordinates[1]; }),
                       ],
                [
                   d3.max(collection.features, function(f){
                       return f.geometry.coordinates[0]; }),
                   d3.max(collection.features, function(f){
                       return f.geometry.coordinates[1]; }),
                      ]
                      ]; // end point bounds
        } else { // if we have polygons or linestrings
            layer.bounds = d3.geo.bounds(collection);
        }
        // d3 setup
        if (layer.customDataFunction == null){ // no special drawing function
            // draw in the default way
            if (layer.featureType == 'Point'){ // if we have points
                layer.features = g.selectAll("circle")
                    .data(collection.features)
                    .enter()
                    .append("circle"); 
            } else { // if we have polygons or linestrings
                layer.bounds = d3.geo.bounds(collection);
                layer.features = g.selectAll("path")
                    .data(collection.features)
                    .enter()
                    .append("path");
            } // end feature setup
        } else { // there is a custom data function
            layer.features = layer.customDataFunction( g, collection);
        }
    return layer;
    }; // end of .data() method

    layer.extent = function() {
        // This method was called in the mapbox example, but doesn't seem to
        // do anything
        var ext = new MM.Extent(
                new MM.Location(layer.bounds[0][1], layer.bounds[0][0]),
                new MM.Location(layer.bounds[1][1], layer.bounds[1][0])
                );
    };
    layer.customDraw = function( drawFunction ){
        /* this method allows for setting a custom draw function
           the draw function must take the svg g element, and the geoJson
           collection for this layer
        */
        layer.customDrawFunction = drawFunction;
    };
    layer.customData = function( dataFunction ){
        /* this method allows for setting a custom data function
           the data function must take the svg g element, and the geoJson
           collection for this layer
           as an argument and must return a d3 selection
        */
        layer.customDataFunction = dataFunction;
    };
    layer.on = function(eventname, listener){
        /* this assigns a event listener to each of the features in this item
           and uses the eventname as the trigger.
       */
        layer.features.on(eventname, listener);
        return layer;
    }
    return layer;
}

function moveToDot(e){
    // When something is clicked, we want to move the map
    // this.__data__ accesses the data associated by d3
    // here, this.__data__ is a geojson
    var coords = this.__data__.geometry.coordinates;
    // get the point.
    map.center( {lat:coords[1], lon:coords[0]}, true );
}

function interviewMarkerData(g, collection){
	var features = g.selectAll("g")
		.data(collection.features)
		.enter()
		.append("g");
  if (isEdit){
  features.append("circle")
    .attr("class", "marker-base")
    .attr("r", baseRadius);
  }
  markers = features.append("a")
		.attr("xlink:href", function(d){
			// add links for now, this will change later
      if (splitPage){
        // we are on a split page
				return "/lottery/map-split/"+d.id+"/";
      } else { // we are on map highlight page
          if (d.id == selectedInterviewId){
            return "/lottery/map-split/"+d.id+"/";
        } else { 
          return "/lottery/map/"+d.id+"/";
          }}}).append("g")
    .attr("class","marker-links");
  markers.append("polygon")
		.attr("class", "interview-marker")
		.attr("points", function(d){
			if (d.id == selectedInterviewId){
				// big marker
				return bmw+",0 0,0 0,"+bmh+" "+((bmw/2)-bsw)+","+bmh+" "+((bmw/2)-bsw)+","+(bmh+bsh)+" "+(bmw/2)+","+bmh+" "+bmw+","+bmh+" ";
			} else {
				// little marker
				return mw+",0 0,0 0,"+mh+" "+((mw/2)-sw)+","+mh+" "+((mw/2)-sw)+","+(mh+sh)+" "+(mw/2)+","+mh+" "+mw+","+mh+" ";
        }})
  markers.append("image")
    .attr("xlink:href", function(d){
        if (d.id == selectedInterviewId){
          return d.properties.photo;
        } else {
          return "";
        }}).attr('width', function(d){
          if (d.id == selectedInterviewId){
            return bmw - 12;
          } else {
            return 0;
        }}).attr('height', function(d){
          if (d.id == selectedInterviewId){
            return bmh - 12;
          } else {
            return 0;
        }});
    return features;
}

function interviewMarkerDraw( features ){
  features.attr("transform",function(d){
        var x = geoJsonProject(d)[0];
        var y = geoJsonProject(d)[1];
        return "translate("+x+","+y+")";
      });
	markers.attr("transform",function(d){
			if (d.id == selectedInterviewId){
				var x = -bmw/2 + bsw;
				var y = -(bmh+bsh);
			} else {
				var x = -mw/2 + sw;
				var y = -(mh+sh);
			}
		return "translate("+x+","+y+")";
		});
}

function setMapSize(){
    w = $(document).width();
    h = $(window).height();
    $('#map').height(h);
}

function splitStyles(){
  $('.bigicon svg g').attr('transform',
      'scale(5,5)');
  $('.quote-delete svg.x g').attr('transform',
      'scale(0.7,0.7)');
  $('.audio-play svg.speaker g').attr('transform',
      'scale(0.7,0.7)');
}

$(window).ready(function(){
    isAuth = {%if is_authenticated%}true{%else%}false{%endif%};
    isEdit = {%if edit_mode%}true{%else%}false{%endif%};
    setMapSize();
    splitStyles();
    // interview location geojsons
	interviewGeoJsons = {{interviewGeoJsons}};
    {% include "lottery/js/interview_data.js" %}
    {% include "lottery/js/input_controller.js" %}
	{% if selected_interview %}
	selectedInterviewId = {{selected_interview}};
	{% endif %}

    var path = window.location.pathname;
    splitPage = (path.indexOf("split") !== -1);

    var basemap = 'sw2279.NewYork';
    
    mapbox.auto('map', basemap, function(obj){
        map = obj;
        // make the layer
        var interviewLayer = d3GeoJsonLayer('d3-vec')
        // edit draw and data functions
        interviewLayer.customData( interviewMarkerData )
        interviewLayer.customDraw( interviewMarkerDraw )
        // add data
        interviewLayer.data(interviewGeoJsons);
        // add listeners
        interviewLayer.on('click', moveToDot);
        // add the layer
        map.addLayer( interviewLayer );

        {% if mapcenter %}
        // center the map
        var center = new MM.Location({{mapcenter.1}}, {{mapcenter.0}});
        map.center( center );
        map.zoom(17); // zoom in 
        {% endif %}

    }); // end mapbox.auto callback

}); // end window ready function
    
</script>
{% endautoescape %}


